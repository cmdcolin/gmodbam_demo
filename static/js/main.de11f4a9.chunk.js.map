{"version":3,"sources":["layout.js","App.js","reportWebVitals.js","index.js"],"names":["minSizeToBotherWith","maxFeaturePitchWidth","LayoutRow","rowNumber","this","padding","sizeLimit","msg","console","log","data","allFilled","x","undefined","min","max","offset","bits","left","right","maxX","Math","getItemAt","rectWidth","Array","rect","l","r","initialize","currLength","length","additionalLength","warn","concat","oLeft","oRight","leftTrimAmount","rightTrimAmount","slice","trimAmount","floor","splice","desiredLength","GranularRectLayout","args","pitchX","pitchY","displayMode","round","bitmap","rectangles","maxHeight","ceil","Infinity","pTotalHeight","id","height","storedRec","top","_addRectToBitmap","pLeft","pRight","pHeight","rectangle","mX","h","maxTop","_collides","maxY","y","row","isRangeClear","av","_autovivifyRow","yEnd","setAllFilled","addRect","discardRange","pY","pX","parseLocString","locString","split","refName","start","end","width","snpcovheight","App","ref","useRef","fileRef","snpcovref","useQueryParams","loc","withDefault","StringParam","file","params","setParams","useState","readData","setReadData","mpileupData","setMPileupData","setFile","setLoc","error","setError","forceUpdate","setTick","useCallback","tick","useForceUpdate","files","setFiles","useEffect","a","bamIdx","name","endsWith","bam","BamFile","bamFilehandle","BlobFile","baiFilehandle","Number","RemoteFile","getHeader","getRecordsForRange","records","vals","fill","filter","f","flags","forEach","s","get","e","i","ctx","current","getContext","clearRect","parsedLoc","bpPerPx","layout","feature","fillStyle","leftPx","fillRect","reduce","b","numReads","fillText","href","onSubmit","event","preventDefault","htmlFor","type","value","style","minWidth","onChange","target","multiple","className","color","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.de11f4a9.chunk.js","sourcesContent":["// minimum excess size of the array at which we garbage collect\nconst minSizeToBotherWith = 10000;\nconst maxFeaturePitchWidth = 200000;\n\n// a single row in the layout\nclass LayoutRow {\n  constructor(rowNumber) {\n    this.rowNumber = rowNumber;\n    this.padding = 1;\n    this.sizeLimit = 10000000;\n\n    // this.offset is the offset of the bits array relative to the genomic coordinates\n    //      (modified by pitchX, but we don't know that in this class)\n    // this.bits is the array of items in the layout row, indexed by (x - this.offset)\n    // this.min is the leftmost edge of all the rectangles we have in the layout\n    // this.max is the rightmost edge of all the rectangles we have in the layout\n  }\n\n  log(msg) {\n    //if (this.rowNumber === 0)\n    console.log(`r${this.rowNumber}: ${msg}`);\n  }\n\n  setAllFilled(data) {\n    this.allFilled = data;\n  }\n\n  getItemAt(x) {\n    if (this.allFilled) return this.allFilled;\n    // return (\n    //     this.min !== undefined &&\n    //     x >= this.min &&\n    //     x <= this.max &&\n    //     this.bits[x - this.min]\n    // )\n\n    if (this.min === undefined) return undefined;\n    if (x < this.min) return undefined;\n    if (x >= this.max) return undefined;\n    const offset = x - this.offset;\n    // if (offset < 0)\n    //     debugger\n    // if (offset >= this.bits.length)\n    //     debugger\n    return this.bits[offset];\n  }\n\n  isRangeClear(left, right) {\n    if (this.allFilled) return false;\n\n    if (this.min === undefined) return true;\n\n    if (right <= this.min || left >= this.max) return true;\n\n    // TODO: check right and middle before looping\n    const maxX = Math.min(this.max, right);\n    let x = Math.max(this.min, left);\n    for (; x < right && x < maxX; x += 1) if (this.getItemAt(x)) return false;\n\n    return true;\n  }\n\n  initialize(left, right) {\n    // NOTE: this.min, this.max, and this.offset are interbase coordinates\n    const rectWidth = right - left;\n    this.offset = left - rectWidth;\n    this.min = left;\n    this.max = right;\n    this.bits = new Array(right - left + 2 * rectWidth);\n    // this.log(`initialize ${this.min} - ${this.max} (${this.bits.length})`)\n  }\n\n  addRect(rect, data) {\n    const left = rect.l;\n    const right = rect.r + this.padding; // only padding on the right\n\n    // initialize if necessary\n    if (this.min === undefined) {\n      this.initialize(left, right);\n    } else {\n      // or check if we need to expand to the left and/or to the right\n\n      // expand rightward by the feature length + whole current length if necessary\n      const currLength = this.bits.length;\n\n      if (right - this.offset >= this.bits.length) {\n        const additionalLength =\n          right - this.offset - this.bits.length + 1 + this.bits.length;\n        if (this.bits.length + additionalLength > this.sizeLimit) {\n          console.warn(\n            `Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.`\n          );\n          this.initialize(left, right);\n        } else if (additionalLength > 0) {\n          this.bits = this.bits.concat(new Array(additionalLength));\n          // this.log(`expand right (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n        }\n      }\n\n      // expand by 2x leftward if necessary\n      if (left < this.offset) {\n        const additionalLength = this.offset - left + currLength;\n        if (this.bits.length + additionalLength > this.sizeLimit) {\n          console.warn(\n            `Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.`\n          );\n          this.initialize(left, right);\n        } else {\n          this.bits = new Array(additionalLength).concat(this.bits);\n          this.offset -= additionalLength;\n          // this.log(`expand left (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n        }\n      }\n    }\n\n    // set the bits in the bitmask\n    const oLeft = left - this.offset;\n    const oRight = right - this.offset;\n    // if (oLeft < 0) debugger\n    // if (oRight < 0) debugger\n    // if (oRight <= oLeft) debugger\n    // if (oRight > this.bits.length) debugger\n    if (oRight - oLeft > maxFeaturePitchWidth) {\n      console.warn(\n        `Layout X pitch set too low, feature spans ${\n          oRight - oLeft\n        } bits in a single row.`,\n        rect,\n        data\n      );\n    }\n\n    for (let x = oLeft; x < oRight; x += 1) {\n      //if (this.bits[x] && this.bits[x].get('name') !== data.get('name')) debugger\n      this.bits[x] = data;\n    }\n\n    if (left < this.min) this.min = left;\n    if (right > this.max) this.max = right;\n    //// this.log(`added ${leftX} - ${rightX}`)\n  }\n\n  /**\n   *  Given a range of interbase coordinates, deletes all data dealing with that range\n   */\n  discardRange(left, right) {\n    if (this.allFilled) return; // allFilled is irrevocable currently\n\n    // if we have no data, do nothing\n    if (!this.bits) return;\n\n    // if doesn't overlap at all, do nothing\n    if (right <= this.min || left >= this.max) return;\n\n    // if completely encloses range, discard everything\n    if (left <= this.min && right >= this.max) {\n      this.min = undefined;\n      this.max = undefined;\n      this.bits = undefined;\n      this.offset = undefined;\n      return;\n    }\n\n    // if overlaps left edge, adjust the min\n    if (right > this.min && left <= this.min) {\n      this.min = right;\n    }\n\n    // if overlaps right edge, adjust the max\n    if (left < this.max && right >= this.max) {\n      this.max = left;\n    }\n\n    // now trim the left, right, or both sides of the array\n    if (\n      this.offset < this.min - minSizeToBotherWith &&\n      this.bits.length > this.max + minSizeToBotherWith - this.offset\n    ) {\n      // trim both sides\n      const leftTrimAmount = this.min - this.offset;\n      const rightTrimAmount = this.bits.length - 1 - (this.max - this.offset);\n      // if (rightTrimAmount <= 0) debugger\n      // if (leftTrimAmount <= 0) debugger\n      // this.log(`trim both sides, ${leftTrimAmount} from left, ${rightTrimAmount} from right`)\n      this.bits = this.bits.slice(\n        leftTrimAmount,\n        this.bits.length - rightTrimAmount\n      );\n      this.offset += leftTrimAmount;\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    } else if (this.offset < this.min - minSizeToBotherWith) {\n      // trim left side\n      const desiredOffset = this.min - Math.floor(minSizeToBotherWith / 2);\n      const trimAmount = desiredOffset - this.offset;\n      // this.log(`trim left side by ${trimAmount}`)\n      this.bits.splice(0, trimAmount);\n      this.offset += trimAmount;\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    } else if (\n      this.bits.length >\n      this.max - this.offset + minSizeToBotherWith\n    ) {\n      // trim right side\n      const desiredLength =\n        this.max - this.offset + 1 + Math.floor(minSizeToBotherWith / 2);\n      // this.log(`trim right side by ${this.bits.length-desiredLength}`)\n      // if (desiredLength > this.bits.length) debugger\n      this.bits.length = desiredLength;\n      // if (this.offset > this.min) debugger\n      // if (this.bits.length <= this.max - this.offset) debugger\n    }\n\n    // if (this.offset > this.min) debugger\n    // if (this.bits.length <= this.max - this.offset) debugger\n\n    // if range now enclosed in the new bounds, loop through and clear the bits\n    const oLeft = Math.max(this.min, left) - this.offset;\n    // if (oLeft < 0) debugger\n    // if (oLeft >= this.bits.length) debugger\n    // if (oRight < 0) debugger\n    // if (oRight >= this.bits.length) debugger\n\n    const oRight = Math.min(right, this.max) - this.offset;\n    for (let x = oLeft; x >= 0 && x < oRight; x += 1) {\n      this.bits[x] = undefined;\n    }\n  }\n}\n\nexport default class GranularRectLayout {\n  /**\n   * @param args.pitchX  layout grid pitch in the X direction\n   * @param args.pitchY  layout grid pitch in the Y direction\n   * @param args.maxHeight  maximum layout height, default Infinity (no max)\n   */\n  constructor(args = {}) {\n    this.pitchX = args.pitchX || 5;\n    this.pitchY = args.pitchY || 3;\n\n    this.displayMode = args.displayMode;\n\n    // reduce the pitchY to try and pack the features tighter\n    if (this.displayMode === \"compact\") {\n      this.pitchY = Math.round(this.pitchY / 4) || 1;\n      this.pitchX = Math.round(this.pitchX / 4) || 1;\n    }\n\n    // console.log(`pitch: ${this.pitchX} / ${this.pitchY}`)\n\n    this.bitmap = [];\n    this.rectangles = {};\n    this.maxHeight = Math.ceil((args.maxHeight || Infinity) / this.pitchY);\n    this.pTotalHeight = 0; // total height, in units of bitmap squares (px/pitchY)\n  }\n\n  /**\n   * @returns {Number} top position for the rect, or Null if laying out the rect would exceed maxHeight\n   */\n  addRect(id, left, right, height, data) {\n    // if we have already laid it out, return its layout\n    if (id in this.rectangles) {\n      const storedRec = this.rectangles[id];\n      if (storedRec.top === null) return null;\n\n      // add it to the bitmap again, since that bitmap range may have been discarded\n      this._addRectToBitmap(storedRec, data);\n      return storedRec.top * this.pitchY;\n    }\n\n    const pLeft = Math.floor(left / this.pitchX);\n    const pRight = Math.floor(right / this.pitchX);\n    const pHeight = Math.ceil(height / this.pitchY);\n\n    const midX = Math.floor((pLeft + pRight) / 2);\n    const rectangle = { id, l: pLeft, r: pRight, mX: midX, h: pHeight };\n    if (data) rectangle.data = data;\n\n    const maxTop = this.maxHeight - pHeight;\n    let top = 0;\n    for (; top <= maxTop; top += 1) {\n      if (!this._collides(rectangle, top)) break;\n    }\n\n    if (top > maxTop) {\n      rectangle.top = top = null;\n      this.rectangles[id] = rectangle;\n      this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight);\n      return null;\n    }\n    rectangle.top = top;\n    this._addRectToBitmap(rectangle, data);\n    this.rectangles[id] = rectangle;\n    this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight);\n    // console.log(`G2 ${data.get('name')} ${top}`)\n    return top * this.pitchY;\n  }\n\n  _collides(rect, top) {\n    if (this.displayMode === \"collapsed\") return false;\n\n    const bitmap = this.bitmap;\n    // var mY = top + rect.h/2; // Y midpoint: ( top+height  + top ) / 2\n\n    // test exhaustively\n    const maxY = top + rect.h;\n    for (let y = top; y < maxY; y += 1) {\n      const row = bitmap[y];\n      if (row && !row.isRangeClear(rect.l, rect.r)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * make a subarray if it does not exist\n   * @private\n   */\n  _autovivifyRow(bitmap, y) {\n    let row = bitmap[y];\n    if (!row) {\n      row = new LayoutRow(y);\n      bitmap[y] = row;\n    }\n    return row;\n  }\n\n  _addRectToBitmap(rect, data) {\n    if (rect.top === null) return;\n\n    data = data || true;\n    const bitmap = this.bitmap;\n    const av = this._autovivifyRow;\n    const yEnd = rect.top + rect.h;\n    if (rect.r - rect.l > maxFeaturePitchWidth) {\n      // the rect is very big in relation to the view size, just\n      // pretend, for the purposes of layout, that it extends\n      // infinitely.  this will cause weird layout if a user\n      // scrolls manually for a very, very long time along the\n      // genome at the same zoom level.  but most users will not\n      // do that.  hopefully.\n      for (let y = rect.top; y < yEnd; y += 1) {\n        av(bitmap, y).setAllFilled(data);\n      }\n    } else {\n      for (let y = rect.top; y < yEnd; y += 1) {\n        av(bitmap, y).addRect(rect, data);\n      }\n    }\n  }\n\n  /**\n   *  Given a range of X coordinates, deletes all data dealing with\n   *  the features.\n   */\n  discardRange(left, right) {\n    // console.log( 'discard', left, right );\n    const pLeft = Math.floor(left / this.pitchX);\n    const pRight = Math.floor(right / this.pitchX);\n    const bitmap = this.bitmap;\n    for (let y = 0; y < bitmap.length; y += 1) {\n      const row = bitmap[y];\n      if (row) row.discardRange(pLeft, pRight);\n    }\n  }\n\n  hasSeen(id) {\n    return !!this.rectangles[id];\n  }\n\n  getByCoord(x, y) {\n    const pY = Math.floor(y / this.pitchY);\n    const row = this.bitmap[pY];\n    if (!row) return undefined;\n    const pX = Math.floor(x / this.pitchX);\n    return row.getItemAt(pX);\n  }\n\n  getByID(id) {\n    const r = this.rectangles[id];\n    if (r) {\n      return r.data || true;\n    }\n    return undefined;\n  }\n\n  cleanup() {}\n\n  getTotalHeight() {\n    return this.pTotalHeight * this.pitchY;\n  }\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { BamFile } from \"@gmod/bam\";\nimport { RemoteFile, BlobFile } from \"generic-filehandle\";\nimport GranularRectLayout from \"./layout\";\nimport { StringParam, useQueryParams, withDefault } from \"use-query-params\";\n\nfunction parseLocString(locString) {\n  const [refName, rest] = locString.split(\":\");\n  const [start, end] = rest.split(\"-\");\n  return { refName, start: +start, end: +end };\n}\n\nexport function parseCigar(cigar) {\n  return (cigar || \"\").split(/([MIDNSHPX=])/);\n}\n\n// because we are using use-query-params without a router\nexport function useForceUpdate() {\n  const [, setTick] = useState(0);\n  const update = useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\n\nconst featHeight = 10;\nconst width = 1800;\nconst height = 1000;\nconst snpcovheight = 100;\nconst initialLoc = \"1:20000-40000\";\nconst initialFile =\n  \"https://s3.amazonaws.com/1000genomes/phase3/data/HG00096/alignment/HG00096.mapped.ILLUMINA.bwa.GBR.low_coverage.20120522.bam\";\n\nfunction App() {\n  const ref = useRef();\n  const fileRef = useRef();\n  const snpcovref = useRef();\n  const [params, setParams] = useQueryParams({\n    loc: withDefault(StringParam, initialLoc),\n    file: withDefault(StringParam, initialFile),\n  });\n  const [readData, setReadData] = useState();\n  const [mpileupData, setMPileupData] = useState();\n  const [file, setFile] = useState(params.file);\n  const [loc, setLoc] = useState(params.loc);\n  const [error, setError] = useState();\n  const forceUpdate = useForceUpdate();\n  const [files, setFiles] = useState();\n\n  useEffect(() => {\n    (async () => {\n      let bam;\n      if (files) {\n        let bamIdx =\n          files[0].name.endsWith(\"bam\") || files[0].name.endsWith(\"cram\")\n            ? 0\n            : 1;\n\n        bam = new BamFile({\n          bamFilehandle: new BlobFile(files[bamIdx]),\n          baiFilehandle: new BlobFile(files[Number(!bamIdx)]),\n        });\n      } else {\n        bam = new BamFile({\n          bamFilehandle: new RemoteFile(params.file),\n          baiFilehandle: new RemoteFile(params.file + \".bai\"),\n        });\n      }\n      await bam.getHeader();\n      const { refName, start, end } = parseLocString(params.loc);\n      var records = await bam.getRecordsForRange(refName, start - 1, end);\n      setReadData(records);\n\n      const vals = new Array(end - start).fill(0);\n      records\n        .filter((f) => !(f.flags & 4) && !(f.flags & 256))\n        .forEach((r) => {\n          const s = r.get(\"start\");\n          const e = r.get(\"end\");\n          for (let i = s - start; i < e - start; i++) {\n            if (i >= 0 && i < end - start) vals[i]++;\n          }\n        });\n      setMPileupData(vals);\n    })();\n  }, [params.file, params.loc, files]);\n\n  // this block draws the rectangles\n  useEffect(() => {\n    const ctx = ref.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, width, height);\n    const parsedLoc = parseLocString(params.loc);\n    const bpPerPx = width / (parsedLoc.end - parsedLoc.start);\n    const layout = new GranularRectLayout();\n    readData?.forEach((feature) => {\n      const start = feature.get(\"start\");\n      const end = feature.get(\"end\");\n      const flags = feature.flags;\n\n      if (flags & 16) {\n        ctx.fillStyle = \"#99f\";\n      } else {\n        ctx.fillStyle = \"#f99\";\n      }\n\n      const leftPx = (start - parsedLoc.start) * bpPerPx;\n      const width = (end - start) * bpPerPx;\n\n      console.log(feature.get(\"name\"), feature.id());\n      const y = layout.addRect(feature.id(), start, end, featHeight);\n\n      ctx.fillRect(leftPx, y, width, featHeight);\n    });\n  }, [readData, params.loc]);\n\n  // this block draws the rectangles\n  useEffect(() => {\n    const ctx = snpcovref.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, width, snpcovheight);\n    const parsedLoc = parseLocString(params.loc);\n    const bpPerPx = width / (parsedLoc.end - parsedLoc.start);\n    if (mpileupData) {\n      const maxHeight = mpileupData.reduce((a, b) => Math.max(a, b), 0);\n      for (let i = 0; i < mpileupData.length; i++) {\n        const numReads = +mpileupData[i];\n        const leftPx = i * bpPerPx;\n        const width = bpPerPx;\n\n        ctx.fillStyle = \"#ccc\";\n        const h = (numReads / maxHeight) * snpcovheight;\n        ctx.fillRect(leftPx, snpcovheight - h, width + 0.9, h);\n      }\n      ctx.fillStyle = \"black\";\n      ctx.fillText(`[0, ${maxHeight}]`, 0, 20);\n    }\n  }, [mpileupData, params.loc]);\n\n  return (\n    <div>\n      <p>\n        Enter BAM/CRAM file and location. This app uses @gmod/bam, compare with{\" \"}\n        <a href=\"https://cmdcolin.github.io/aioli_demo/\">\n          https://cmdcolin.github.io/aioli_demo/\n        </a>\n      </p>\n      <form\n        onSubmit={(event) => {\n          setParams({ file, loc });\n          if (fileRef.current.files.length) {\n            setFiles(fileRef.current.files);\n          }\n          setMPileupData();\n          setReadData();\n          setError();\n          forceUpdate();\n          event.preventDefault();\n        }}\n      >\n        <label htmlFor=\"url\">URL: </label>\n        <input\n          id=\"url\"\n          type=\"text\"\n          value={file}\n          style={{ minWidth: \"75%\" }}\n          onChange={(event) => setFile(event.target.value)}\n        />\n\n        <br />\n        <label htmlFor=\"file\">File (import both BAM and BAI): </label>\n        <input id=\"file\" ref={fileRef} type=\"file\" multiple />\n\n        <br />\n        <label htmlFor=\"loc\">Location: </label>\n        <input\n          id=\"loc\"\n          type=\"text\"\n          value={loc}\n          onChange={(event) => setLoc(event.target.value)}\n        />\n        <button type=\"submit\">Submit</button>\n      </form>\n      {!readData ? <div className=\"dots\">Loading...</div> : null}\n      {error ? <div style={{ color: \"red\" }}>{error}</div> : null}\n      <canvas ref={snpcovref} width={width} height={snpcovheight} />\n      <canvas ref={ref} width={width} height={height} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { QueryParamProvider } from \"use-query-params\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <QueryParamProvider>\n      <App />\n    </QueryParamProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}